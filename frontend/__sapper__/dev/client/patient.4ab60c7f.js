import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, b as validate_slots, e as element, t as text, f as space, h as claim_element, j as children, k as claim_text, l as detach_dev, m as claim_space, o as attr_dev, n as add_location, q as insert_dev, r as append_dev, x as set_data_dev, A as noop, a as stores$1, v as validate_store, c as component_subscribe, u as set_input_value, w as listen_dev, y as prop_dev, z as run_all, B as empty, L as onMount, E as transition_in, C as transition_out, D as check_outros, H as create_component, I as claim_component, J as mount_component, K as destroy_component, M as validate_each_argument, N as destroy_each, G as group_outros } from './client.12c0cabd.js';
import { P as Patient } from './Patient.6c636d19.js';

/* src\components\HealthNoteView.svelte generated by Svelte v3.24.0 */

const file = "src\\components\\HealthNoteView.svelte";

function create_fragment(ctx) {
	let div;
	let table;
	let tr0;
	let td0;
	let t0;
	let t1;
	let td1;
	let t2_value = /*healthNote*/ ctx[0].note + "";
	let t2;
	let t3;
	let tr1;
	let td2;
	let t4;
	let t5;
	let td3;
	let t6_value = /*healthNote*/ ctx[0].userid + "";
	let t6;
	let t7;
	let tr2;
	let td4;
	let t8;
	let t9;
	let td5;
	let t10_value = new Date(/*healthNote*/ ctx[0].created) + "";
	let t10;

	const block = {
		c: function create() {
			div = element("div");
			table = element("table");
			tr0 = element("tr");
			td0 = element("td");
			t0 = text("Health Note:");
			t1 = space();
			td1 = element("td");
			t2 = text(t2_value);
			t3 = space();
			tr1 = element("tr");
			td2 = element("td");
			t4 = text("Nurse ID:");
			t5 = space();
			td3 = element("td");
			t6 = text(t6_value);
			t7 = space();
			tr2 = element("tr");
			td4 = element("td");
			t8 = text("Date:");
			t9 = space();
			td5 = element("td");
			t10 = text(t10_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			table = claim_element(div_nodes, "TABLE", { class: true });
			var table_nodes = children(table);
			tr0 = claim_element(table_nodes, "TR", {});
			var tr0_nodes = children(tr0);
			td0 = claim_element(tr0_nodes, "TD", { class: true });
			var td0_nodes = children(td0);
			t0 = claim_text(td0_nodes, "Health Note:");
			td0_nodes.forEach(detach_dev);
			t1 = claim_space(tr0_nodes);
			td1 = claim_element(tr0_nodes, "TD", { class: true });
			var td1_nodes = children(td1);
			t2 = claim_text(td1_nodes, t2_value);
			td1_nodes.forEach(detach_dev);
			tr0_nodes.forEach(detach_dev);
			t3 = claim_space(table_nodes);
			tr1 = claim_element(table_nodes, "TR", {});
			var tr1_nodes = children(tr1);
			td2 = claim_element(tr1_nodes, "TD", { class: true });
			var td2_nodes = children(td2);
			t4 = claim_text(td2_nodes, "Nurse ID:");
			td2_nodes.forEach(detach_dev);
			t5 = claim_space(tr1_nodes);
			td3 = claim_element(tr1_nodes, "TD", { class: true });
			var td3_nodes = children(td3);
			t6 = claim_text(td3_nodes, t6_value);
			td3_nodes.forEach(detach_dev);
			tr1_nodes.forEach(detach_dev);
			t7 = claim_space(table_nodes);
			tr2 = claim_element(table_nodes, "TR", {});
			var tr2_nodes = children(tr2);
			td4 = claim_element(tr2_nodes, "TD", { class: true });
			var td4_nodes = children(td4);
			t8 = claim_text(td4_nodes, "Date:");
			td4_nodes.forEach(detach_dev);
			t9 = claim_space(tr2_nodes);
			td5 = claim_element(tr2_nodes, "TD", { class: true });
			var td5_nodes = children(td5);
			t10 = claim_text(td5_nodes, t10_value);
			td5_nodes.forEach(detach_dev);
			tr2_nodes.forEach(detach_dev);
			table_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(td0, "class", "svelte-1od0orj");
			add_location(td0, file, 22, 6, 281);
			attr_dev(td1, "class", "svelte-1od0orj");
			add_location(td1, file, 23, 6, 309);
			add_location(tr0, file, 21, 4, 270);
			attr_dev(td2, "class", "svelte-1od0orj");
			add_location(td2, file, 26, 6, 361);
			attr_dev(td3, "class", "svelte-1od0orj");
			add_location(td3, file, 27, 6, 386);
			add_location(tr1, file, 25, 4, 350);
			attr_dev(td4, "class", "svelte-1od0orj");
			add_location(td4, file, 30, 6, 440);
			attr_dev(td5, "class", "svelte-1od0orj");
			add_location(td5, file, 31, 6, 461);
			add_location(tr2, file, 29, 4, 429);
			attr_dev(table, "class", "svelte-1od0orj");
			add_location(table, file, 20, 2, 258);
			attr_dev(div, "class", "svelte-1od0orj");
			add_location(div, file, 19, 0, 250);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, table);
			append_dev(table, tr0);
			append_dev(tr0, td0);
			append_dev(td0, t0);
			append_dev(tr0, t1);
			append_dev(tr0, td1);
			append_dev(td1, t2);
			append_dev(table, t3);
			append_dev(table, tr1);
			append_dev(tr1, td2);
			append_dev(td2, t4);
			append_dev(tr1, t5);
			append_dev(tr1, td3);
			append_dev(td3, t6);
			append_dev(table, t7);
			append_dev(table, tr2);
			append_dev(tr2, td4);
			append_dev(td4, t8);
			append_dev(tr2, t9);
			append_dev(tr2, td5);
			append_dev(td5, t10);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*healthNote*/ 1 && t2_value !== (t2_value = /*healthNote*/ ctx[0].note + "")) set_data_dev(t2, t2_value);
			if (dirty & /*healthNote*/ 1 && t6_value !== (t6_value = /*healthNote*/ ctx[0].userid + "")) set_data_dev(t6, t6_value);
			if (dirty & /*healthNote*/ 1 && t10_value !== (t10_value = new Date(/*healthNote*/ ctx[0].created) + "")) set_data_dev(t10, t10_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { healthNote } = $$props;
	const writable_props = ["healthNote"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HealthNoteView> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("HealthNoteView", $$slots, []);

	$$self.$set = $$props => {
		if ("healthNote" in $$props) $$invalidate(0, healthNote = $$props.healthNote);
	};

	$$self.$capture_state = () => ({ healthNote });

	$$self.$inject_state = $$props => {
		if ("healthNote" in $$props) $$invalidate(0, healthNote = $$props.healthNote);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [healthNote];
}

class HealthNoteView extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { healthNote: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "HealthNoteView",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*healthNote*/ ctx[0] === undefined && !("healthNote" in props)) {
			console.warn("<HealthNoteView> was created without expected prop 'healthNote'");
		}
	}

	get healthNote() {
		throw new Error("<HealthNoteView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set healthNote(value) {
		throw new Error("<HealthNoteView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\HealthNoteEdit.svelte generated by Svelte v3.24.0 */
const file$1 = "src\\components\\HealthNoteEdit.svelte";

// (52:0) {#if $session && $session.authenticated}
function create_if_block_1(ctx) {
	let div;
	let t0;
	let br0;
	let t1;
	let t2_value = /*patient*/ ctx[0].name + "";
	let t2;
	let t3;
	let t4_value = /*patient*/ ctx[0].patientid + "";
	let t4;
	let t5;
	let br1;
	let t6;
	let textarea;
	let br2;
	let t7;
	let t8_value = /*$session*/ ctx[4].profile.name + "";
	let t8;
	let t9;
	let t10_value = /*$session*/ ctx[4].profile.username + "";
	let t10;
	let t11;
	let br3;
	let t12;
	let button;
	let t13;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			t0 = text("Add new note:");
			br0 = element("br");
			t1 = text("\n  patient : ");
			t2 = text(t2_value);
			t3 = text(" (");
			t4 = text(t4_value);
			t5 = text(")");
			br1 = element("br");
			t6 = space();
			textarea = element("textarea");
			br2 = element("br");
			t7 = text("\n  by : ");
			t8 = text(t8_value);
			t9 = text(" (");
			t10 = text(t10_value);
			t11 = text(")");
			br3 = element("br");
			t12 = space();
			button = element("button");
			t13 = text("save");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, "Add new note:");
			br0 = claim_element(div_nodes, "BR", {});
			t1 = claim_text(div_nodes, "\n  patient : ");
			t2 = claim_text(div_nodes, t2_value);
			t3 = claim_text(div_nodes, " (");
			t4 = claim_text(div_nodes, t4_value);
			t5 = claim_text(div_nodes, ")");
			br1 = claim_element(div_nodes, "BR", {});
			t6 = claim_space(div_nodes);
			textarea = claim_element(div_nodes, "TEXTAREA", { class: true });
			children(textarea).forEach(detach_dev);
			br2 = claim_element(div_nodes, "BR", {});
			t7 = claim_text(div_nodes, "\n  by : ");
			t8 = claim_text(div_nodes, t8_value);
			t9 = claim_text(div_nodes, " (");
			t10 = claim_text(div_nodes, t10_value);
			t11 = claim_text(div_nodes, ")");
			br3 = claim_element(div_nodes, "BR", {});
			t12 = claim_space(div_nodes);
			button = claim_element(div_nodes, "BUTTON", { disabled: true });
			var button_nodes = children(button);
			t13 = claim_text(button_nodes, "save");
			button_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(br0, file$1, 53, 15, 1106);
			add_location(br1, file$1, 54, 48, 1160);
			attr_dev(textarea, "class", "svelte-vjzopz");
			add_location(textarea, file$1, 55, 2, 1168);
			add_location(br2, file$1, 55, 41, 1207);
			add_location(br3, file$1, 56, 60, 1273);
			button.disabled = /*loading*/ ctx[3];
			add_location(button, file$1, 57, 2, 1281);
			attr_dev(div, "class", "svelte-vjzopz");
			add_location(div, file$1, 52, 2, 1085);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, br0);
			append_dev(div, t1);
			append_dev(div, t2);
			append_dev(div, t3);
			append_dev(div, t4);
			append_dev(div, t5);
			append_dev(div, br1);
			append_dev(div, t6);
			append_dev(div, textarea);
			set_input_value(textarea, /*note*/ ctx[1]);
			append_dev(div, br2);
			append_dev(div, t7);
			append_dev(div, t8);
			append_dev(div, t9);
			append_dev(div, t10);
			append_dev(div, t11);
			append_dev(div, br3);
			append_dev(div, t12);
			append_dev(div, button);
			append_dev(button, t13);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[8]),
					listen_dev(button, "click", /*onSave*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*patient*/ 1 && t2_value !== (t2_value = /*patient*/ ctx[0].name + "")) set_data_dev(t2, t2_value);
			if (dirty & /*patient*/ 1 && t4_value !== (t4_value = /*patient*/ ctx[0].patientid + "")) set_data_dev(t4, t4_value);

			if (dirty & /*note*/ 2) {
				set_input_value(textarea, /*note*/ ctx[1]);
			}

			if (dirty & /*$session*/ 16 && t8_value !== (t8_value = /*$session*/ ctx[4].profile.name + "")) set_data_dev(t8, t8_value);
			if (dirty & /*$session*/ 16 && t10_value !== (t10_value = /*$session*/ ctx[4].profile.username + "")) set_data_dev(t10, t10_value);

			if (dirty & /*loading*/ 8) {
				prop_dev(button, "disabled", /*loading*/ ctx[3]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(52:0) {#if $session && $session.authenticated}",
		ctx
	});

	return block;
}

// (61:0) {#if error}
function create_if_block(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*error*/ ctx[2]);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, /*error*/ ctx[2]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*error*/ 4) set_data_dev(t, /*error*/ ctx[2]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(61:0) {#if error}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let t;
	let if_block1_anchor;
	let if_block0 = /*$session*/ ctx[4] && /*$session*/ ctx[4].authenticated && create_if_block_1(ctx);
	let if_block1 = /*error*/ ctx[2] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block0) if_block0.l(nodes);
			t = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (/*$session*/ ctx[4] && /*$session*/ ctx[4].authenticated) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*error*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let $session;
	const { session } = stores$1();
	validate_store(session, "session");
	component_subscribe($$self, session, value => $$invalidate(4, $session = value));
	let { patient } = $$props;
	let { onUpdated } = $$props;
	let note = "";
	let error;
	let loading = false;

	async function onSave() {
		$$invalidate(3, loading = true);

		if (note.length == 0) {
			$$invalidate(2, error = "health note must not be empty");
			return;
		}

		var newNote = {
			userid: $session.profile.username,
			patientid: patient.patientid,
			note
		};

		const response = await fetch("http://localhost:8000/api/v1/patient/note", {
			method: "POST",
			mode: "cors",
			credentials: "include",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify(newNote)
		});

		if (response.ok) {
			$$invalidate(2, error = null);
			$$invalidate(1, note = "");
			if (onUpdated != null) onUpdated();
		} else {
			$$invalidate(2, error = await response.text());
		}

		$$invalidate(3, loading = false);
	}

	const writable_props = ["patient", "onUpdated"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HealthNoteEdit> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("HealthNoteEdit", $$slots, []);

	function textarea_input_handler() {
		note = this.value;
		$$invalidate(1, note);
	}

	$$self.$set = $$props => {
		if ("patient" in $$props) $$invalidate(0, patient = $$props.patient);
		if ("onUpdated" in $$props) $$invalidate(7, onUpdated = $$props.onUpdated);
	};

	$$self.$capture_state = () => ({
		stores: stores$1,
		session,
		patient,
		onUpdated,
		note,
		error,
		loading,
		onSave,
		$session
	});

	$$self.$inject_state = $$props => {
		if ("patient" in $$props) $$invalidate(0, patient = $$props.patient);
		if ("onUpdated" in $$props) $$invalidate(7, onUpdated = $$props.onUpdated);
		if ("note" in $$props) $$invalidate(1, note = $$props.note);
		if ("error" in $$props) $$invalidate(2, error = $$props.error);
		if ("loading" in $$props) $$invalidate(3, loading = $$props.loading);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		patient,
		note,
		error,
		loading,
		$session,
		session,
		onSave,
		onUpdated,
		textarea_input_handler
	];
}

class HealthNoteEdit extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { patient: 0, onUpdated: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "HealthNoteEdit",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*patient*/ ctx[0] === undefined && !("patient" in props)) {
			console.warn("<HealthNoteEdit> was created without expected prop 'patient'");
		}

		if (/*onUpdated*/ ctx[7] === undefined && !("onUpdated" in props)) {
			console.warn("<HealthNoteEdit> was created without expected prop 'onUpdated'");
		}
	}

	get patient() {
		throw new Error("<HealthNoteEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set patient(value) {
		throw new Error("<HealthNoteEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onUpdated() {
		throw new Error("<HealthNoteEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onUpdated(value) {
		throw new Error("<HealthNoteEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\routes\patient.svelte generated by Svelte v3.24.0 */
const file$2 = "src\\routes\\patient.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	return child_ctx;
}

// (60:0) {#if $session && $session.authenticated && patient && newNote}
function create_if_block_1$1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*patient*/ ctx[0] && create_if_block_2(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*patient*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*patient*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(60:0) {#if $session && $session.authenticated && patient && newNote}",
		ctx
	});

	return block;
}

// (61:2) {#if patient}
function create_if_block_2(ctx) {
	let patient_1;
	let t0;
	let t1;
	let if_block1_anchor;
	let current;

	patient_1 = new Patient({
			props: { patient: /*patient*/ ctx[0] },
			$$inline: true
		});

	let if_block0 = /*healthNotes*/ ctx[1] && create_if_block_4(ctx);
	let if_block1 = /*patient*/ ctx[0] && create_if_block_3(ctx);

	const block = {
		c: function create() {
			create_component(patient_1.$$.fragment);
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		l: function claim(nodes) {
			claim_component(patient_1.$$.fragment, nodes);
			t0 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t1 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
		},
		m: function mount(target, anchor) {
			mount_component(patient_1, target, anchor);
			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const patient_1_changes = {};
			if (dirty & /*patient*/ 1) patient_1_changes.patient = /*patient*/ ctx[0];
			patient_1.$set(patient_1_changes);

			if (/*healthNotes*/ ctx[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*healthNotes*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*patient*/ ctx[0]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*patient*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(patient_1.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(patient_1.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(patient_1, detaching);
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(61:2) {#if patient}",
		ctx
	});

	return block;
}

// (63:4) {#if healthNotes}
function create_if_block_4(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*healthNotes*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*healthNotes*/ 2) {
				each_value = /*healthNotes*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(63:4) {#if healthNotes}",
		ctx
	});

	return block;
}

// (64:6) {#each healthNotes as healthNote}
function create_each_block(ctx) {
	let healthnoteview;
	let current;

	healthnoteview = new HealthNoteView({
			props: { healthNote: /*healthNote*/ ctx[8] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(healthnoteview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(healthnoteview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(healthnoteview, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const healthnoteview_changes = {};
			if (dirty & /*healthNotes*/ 2) healthnoteview_changes.healthNote = /*healthNote*/ ctx[8];
			healthnoteview.$set(healthnoteview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(healthnoteview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(healthnoteview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(healthnoteview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(64:6) {#each healthNotes as healthNote}",
		ctx
	});

	return block;
}

// (68:4) {#if patient}
function create_if_block_3(ctx) {
	let healthnoteedit;
	let current;

	healthnoteedit = new HealthNoteEdit({
			props: {
				onUpdated: /*refreshNotes*/ ctx[6],
				healthNote: /*newNote*/ ctx[3],
				patient: /*patient*/ ctx[0]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(healthnoteedit.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(healthnoteedit.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(healthnoteedit, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const healthnoteedit_changes = {};
			if (dirty & /*newNote*/ 8) healthnoteedit_changes.healthNote = /*newNote*/ ctx[3];
			if (dirty & /*patient*/ 1) healthnoteedit_changes.patient = /*patient*/ ctx[0];
			healthnoteedit.$set(healthnoteedit_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(healthnoteedit.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(healthnoteedit.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(healthnoteedit, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(68:4) {#if patient}",
		ctx
	});

	return block;
}

// (73:0) {#if error}
function create_if_block$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*error*/ ctx[2]);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, /*error*/ ctx[2]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*error*/ 4) set_data_dev(t, /*error*/ ctx[2]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(73:0) {#if error}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let h1;
	let t0;
	let t1;
	let t2;
	let if_block1_anchor;
	let current;
	let if_block0 = /*$session*/ ctx[4] && /*$session*/ ctx[4].authenticated && /*patient*/ ctx[0] && /*newNote*/ ctx[3] && create_if_block_1$1(ctx);
	let if_block1 = /*error*/ ctx[2] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Patient");
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Patient");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t2 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$2, 58, 0, 1412);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*$session*/ ctx[4] && /*$session*/ ctx[4].authenticated && /*patient*/ ctx[0] && /*newNote*/ ctx[3]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*$session, patient, newNote*/ 25) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t2.parentNode, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*error*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let $session;
	const { session } = stores$1();
	validate_store(session, "session");
	component_subscribe($$self, session, value => $$invalidate(4, $session = value));
	let patient;
	let healthNotes;
	let error;
	let patientid;
	let newNote;

	onMount(async () => {
		let tokens = window.location.search.split("patientid=");
		patientid = tokens[tokens.length - 1];
		$$invalidate(3, newNote = { note: "", patientid });

		const response = await fetch("http://localhost:8000/api/v1/patient?patientid=" + patientid, {
			method: "GET",
			mode: "cors",
			credentials: "include",
			headers: { "Content-Type": "application/json" }
		});

		if (response.ok) {
			$$invalidate(2, error = null);
			$$invalidate(0, patient = await response.json());
		} else {
			$$invalidate(2, error = await response.text());
		}
	});

	var refreshNotes = async () => {
		const response = await fetch("http://localhost:8000/api/v1/patient/notes?patientid=" + patientid, {
			method: "GET",
			mode: "cors",
			credentials: "include",
			headers: { "Content-Type": "application/json" }
		});

		if (response.ok) {
			$$invalidate(2, error = null);
			$$invalidate(1, healthNotes = await response.json());
		} else {
			$$invalidate(2, error = await response.text());
		}
	};

	onMount(refreshNotes);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Patient> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Patient", $$slots, []);

	$$self.$capture_state = () => ({
		onMount,
		stores: stores$1,
		Patient,
		HealthNoteView,
		HealthNoteEdit,
		session,
		patient,
		healthNotes,
		error,
		patientid,
		newNote,
		refreshNotes,
		$session
	});

	$$self.$inject_state = $$props => {
		if ("patient" in $$props) $$invalidate(0, patient = $$props.patient);
		if ("healthNotes" in $$props) $$invalidate(1, healthNotes = $$props.healthNotes);
		if ("error" in $$props) $$invalidate(2, error = $$props.error);
		if ("patientid" in $$props) patientid = $$props.patientid;
		if ("newNote" in $$props) $$invalidate(3, newNote = $$props.newNote);
		if ("refreshNotes" in $$props) $$invalidate(6, refreshNotes = $$props.refreshNotes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [patient, healthNotes, error, newNote, $session, session, refreshNotes];
}

class Patient_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Patient_1",
			options,
			id: create_fragment$2.name
		});
	}
}

export default Patient_1;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGF0aWVudC40YWI2MGM3Zi5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvSGVhbHRoTm90ZVZpZXcuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvSGVhbHRoTm90ZUVkaXQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9wYXRpZW50LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICBleHBvcnQgbGV0IGhlYWx0aE5vdGVcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIGRpdiB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1MSwgMjUyLCAyMDYpO1xuICAgIHBhZGRpbmc6IDVweDtcbiAgICBtYXJnaW46IDVweDtcbiAgfVxuICB0YWJsZSB7XG4gICAgd2lkdGg6IDEwMCU7XG4gIH1cbiAgdGQge1xuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgICB2ZXJ0aWNhbC1hbGlnbjogdGV4dC10b3A7XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXY+XG4gIDx0YWJsZT5cbiAgICA8dHI+XG4gICAgICA8dGQ+SGVhbHRoIE5vdGU6PC90ZD5cbiAgICAgIDx0ZD57aGVhbHRoTm90ZS5ub3RlfTwvdGQ+XG4gICAgPC90cj5cbiAgICA8dHI+XG4gICAgICA8dGQ+TnVyc2UgSUQ6PC90ZD5cbiAgICAgIDx0ZD57aGVhbHRoTm90ZS51c2VyaWR9PC90ZD5cbiAgICA8L3RyPlxuICAgIDx0cj5cbiAgICAgIDx0ZD5EYXRlOjwvdGQ+XG4gICAgICA8dGQ+e25ldyBEYXRlKGhlYWx0aE5vdGUuY3JlYXRlZCl9PC90ZD5cbiAgICA8L3RyPlxuICA8L3RhYmxlPlxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBzdG9yZXMgfSBmcm9tICdAc2FwcGVyL2FwcCdcbiAgXG4gIGNvbnN0IHsgc2Vzc2lvbiB9ID0gc3RvcmVzKClcbiAgZXhwb3J0IGxldCBwYXRpZW50XG4gIGV4cG9ydCBsZXQgb25VcGRhdGVkXG4gIGxldCBub3RlID0gXCJcIlxuICBsZXQgZXJyb3JcbiAgbGV0IGxvYWRpbmcgPSBmYWxzZVxuXG4gIGFzeW5jIGZ1bmN0aW9uIG9uU2F2ZSgpIHtcbiAgICBsb2FkaW5nID0gdHJ1ZVxuICAgIGlmIChub3RlLmxlbmd0aCA9PSAwKSB7XG4gICAgICBlcnJvciA9IFwiaGVhbHRoIG5vdGUgbXVzdCBub3QgYmUgZW1wdHlcIlxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBuZXdOb3RlID0ge1xuICAgICAgdXNlcmlkOiAkc2Vzc2lvbi5wcm9maWxlLnVzZXJuYW1lLFxuICAgICAgcGF0aWVudGlkOiBwYXRpZW50LnBhdGllbnRpZCxcbiAgICAgIG5vdGU6IG5vdGVcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaS92MS9wYXRpZW50L25vdGUnLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShuZXdOb3RlKVxuICAgIH0pXG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBlcnJvciA9IG51bGxcbiAgICAgIG5vdGUgPSBcIlwiXG4gICAgICBpZiAob25VcGRhdGVkICE9IG51bGwpIG9uVXBkYXRlZCgpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZXJyb3IgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICB9XG4gICAgbG9hZGluZyA9IGZhbHNlXG4gIH1cbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIGRpdiB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI0MSwgMjQxLCAyNDApO1xuICAgIHBhZGRpbmc6IDVweDtcbiAgICBtYXJnaW46IDVweDtcbiAgfVxuXHR0ZXh0YXJlYSB7IHdpZHRoOiA5NSU7IGhlaWdodDogMjAwcHg7IH1cbjwvc3R5bGU+XG5cbnsjaWYgJHNlc3Npb24gJiYgJHNlc3Npb24uYXV0aGVudGljYXRlZH1cbiAgPGRpdj5cbiAgQWRkIG5ldyBub3RlOjxici8+XG4gIHBhdGllbnQgOiB7cGF0aWVudC5uYW1lfSAoe3BhdGllbnQucGF0aWVudGlkfSk8YnIvPlxuICA8dGV4dGFyZWEgYmluZDp2YWx1ZT17bm90ZX0+PC90ZXh0YXJlYT48YnIvPlxuICBieSA6IHskc2Vzc2lvbi5wcm9maWxlLm5hbWV9ICh7JHNlc3Npb24ucHJvZmlsZS51c2VybmFtZX0pPGJyLz5cbiAgPGJ1dHRvbiBkaXNhYmxlZD17bG9hZGluZ30gb246Y2xpY2s9e29uU2F2ZX0+c2F2ZTwvYnV0dG9uPlxuICA8L2Rpdj5cbnsvaWZ9XG57I2lmIGVycm9yfVxuICB7ZXJyb3J9XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IHN0b3JlcyB9IGZyb20gJ0BzYXBwZXIvYXBwJ1xuICBpbXBvcnQgUGF0aWVudCBmcm9tICcuLi9jb21wb25lbnRzL1BhdGllbnQuc3ZlbHRlJztcbiAgaW1wb3J0IEhlYWx0aE5vdGVWaWV3IGZyb20gJy4uL2NvbXBvbmVudHMvSGVhbHRoTm90ZVZpZXcuc3ZlbHRlJztcbiAgaW1wb3J0IEhlYWx0aE5vdGVFZGl0IGZyb20gJy4uL2NvbXBvbmVudHMvSGVhbHRoTm90ZUVkaXQuc3ZlbHRlJztcbiAgXG4gIGNvbnN0IHsgc2Vzc2lvbiB9ID0gc3RvcmVzKClcbiAgbGV0IHBhdGllbnRcbiAgbGV0IGhlYWx0aE5vdGVzO1xuICBsZXQgZXJyb3JcblxuICBsZXQgcGF0aWVudGlkXG4gIGxldCBuZXdOb3RlXG5cblx0b25Nb3VudChhc3luYyAoKSA9PiB7XG4gICAgbGV0IHRva2VucyA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3BsaXQoXCJwYXRpZW50aWQ9XCIpXG4gICAgcGF0aWVudGlkID0gdG9rZW5zW3Rva2Vucy5sZW5ndGgtMV1cbiAgICBuZXdOb3RlID0geyBub3RlOiBcIlwiLCAgcGF0aWVudGlkfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaS92MS9wYXRpZW50P3BhdGllbnRpZD0nICsgcGF0aWVudGlkLCB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgbW9kZTogJ2NvcnMnLFxuICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBlcnJvciA9IG51bGxcbiAgICAgIHBhdGllbnQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZXJyb3IgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICB9XG5cdH0pOyAgICBcblxuICB2YXIgcmVmcmVzaE5vdGVzID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9hcGkvdjEvcGF0aWVudC9ub3Rlcz9wYXRpZW50aWQ9JyArIHBhdGllbnRpZCwge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgZXJyb3IgPSBudWxsXG4gICAgICBoZWFsdGhOb3RlcyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgIH1cbiAgfVxuXG5cdG9uTW91bnQocmVmcmVzaE5vdGVzKTsgIFxuPC9zY3JpcHQ+XG5cbjxoMT5QYXRpZW50PC9oMT5cbnsjaWYgJHNlc3Npb24gJiYgJHNlc3Npb24uYXV0aGVudGljYXRlZCAmJiBwYXRpZW50ICYmIG5ld05vdGV9XG4gIHsjaWYgcGF0aWVudH1cbiAgICA8UGF0aWVudCBwYXRpZW50PXtwYXRpZW50fS8+XG4gICAgeyNpZiBoZWFsdGhOb3Rlc31cbiAgICAgIHsjZWFjaCBoZWFsdGhOb3RlcyBhcyBoZWFsdGhOb3RlfVxuICAgICAgICA8SGVhbHRoTm90ZVZpZXcgaGVhbHRoTm90ZT17aGVhbHRoTm90ZX0vPlxuICAgICAgey9lYWNofVxuICAgIHsvaWZ9XG4gICAgeyNpZiBwYXRpZW50fVxuICAgICAgPEhlYWx0aE5vdGVFZGl0IG9uVXBkYXRlZD17cmVmcmVzaE5vdGVzfSBoZWFsdGhOb3RlPXtuZXdOb3RlfSBwYXRpZW50PXtwYXRpZW50fS8+XG4gICAgey9pZn1cbiAgey9pZn1cbnsvaWZ9XG57I2lmIGVycm9yfVxuICB7ZXJyb3J9XG57L2lmfVxuIl0sIm5hbWVzIjpbInN0b3JlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OytCQXVCVyxHQUFVLElBQUMsSUFBSTs7Ozs7Ozs7K0JBSWYsR0FBVSxJQUFDLE1BQU07Ozs7Ozs7O3FCQUliLElBQUksZ0JBQUMsR0FBVSxJQUFDLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJFQVIzQixHQUFVLElBQUMsSUFBSTsyRUFJZixHQUFVLElBQUMsTUFBTTtrRUFJYixJQUFJLGdCQUFDLEdBQVUsSUFBQyxPQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
