import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, a as stores$1, v as validate_store, c as component_subscribe, b as validate_slots, g as goto, e as element, t as text, f as space, h as claim_element, j as children, k as claim_text, l as detach_dev, m as claim_space, n as add_location, o as attr_dev, p as set_style, q as insert_dev, r as append_dev, u as set_input_value, w as listen_dev, x as set_data_dev, y as prop_dev, z as run_all, A as noop, B as empty, C as transition_out, D as check_outros, E as transition_in, F as query_selector_all, G as group_outros, H as create_component, I as claim_component, J as mount_component, K as destroy_component } from './client.12c0cabd.js';

function DoLogin(username, password) {
  return fetch('http://localhost:8000/api/v1/session', {
    method: 'POST',
    mode: 'cors',
    credentials: 'include',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      username,
      password
    })
  })
}

function DoRegister(user) {
  return fetch('http://localhost:8000/api/v1/register', {
    method: 'POST',
    mode: 'cors',
    credentials: 'include',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(user)
  })
}

/* src\components\Login.svelte generated by Svelte v3.24.0 */
const file = "src\\components\\Login.svelte";

// (97:0) {#if $session && !$session.loading}
function create_if_block(ctx) {
	let p;
	let t0;
	let t1;
	let table;
	let tbody;
	let tr0;
	let td0;
	let t2;
	let t3;
	let td1;
	let input0;
	let t4;
	let t5;
	let tr1;
	let td2;
	let t6;
	let t7;
	let td3;
	let input1;
	let t8;
	let tr2;
	let td4;
	let t9;
	let t10;
	let td5;
	let input2;
	let t11;
	let t12;
	let t13;
	let tr3;
	let td6;
	let t14;
	let td7;
	let button;
	let t15_value = (/*register*/ ctx[4] ? "register" : "login") + "";
	let t15;
	let button_disabled_value;
	let mounted;
	let dispose;
	let if_block0 = /*register*/ ctx[4] && create_if_block_3(ctx);
	let if_block1 = /*register*/ ctx[4] && create_if_block_2(ctx);
	let if_block2 = /*error*/ ctx[5] && create_if_block_1(ctx);

	const block = {
		c: function create() {
			p = element("p");
			t0 = text("Nurse Login");
			t1 = space();
			table = element("table");
			tbody = element("tbody");
			tr0 = element("tr");
			td0 = element("td");
			t2 = text("Register new user ?");
			t3 = space();
			td1 = element("td");
			input0 = element("input");
			t4 = space();
			if (if_block0) if_block0.c();
			t5 = space();
			tr1 = element("tr");
			td2 = element("td");
			t6 = text("Login ID:");
			t7 = space();
			td3 = element("td");
			input1 = element("input");
			t8 = space();
			tr2 = element("tr");
			td4 = element("td");
			t9 = text("Password:");
			t10 = space();
			td5 = element("td");
			input2 = element("input");
			t11 = space();
			if (if_block1) if_block1.c();
			t12 = space();
			if (if_block2) if_block2.c();
			t13 = space();
			tr3 = element("tr");
			td6 = element("td");
			t14 = space();
			td7 = element("td");
			button = element("button");
			t15 = text(t15_value);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "Nurse Login");
			p_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			table = claim_element(nodes, "TABLE", {});
			var table_nodes = children(table);
			tbody = claim_element(table_nodes, "TBODY", {});
			var tbody_nodes = children(tbody);
			tr0 = claim_element(tbody_nodes, "TR", { class: true });
			var tr0_nodes = children(tr0);
			td0 = claim_element(tr0_nodes, "TD", { class: true });
			var td0_nodes = children(td0);
			t2 = claim_text(td0_nodes, "Register new user ?");
			td0_nodes.forEach(detach_dev);
			t3 = claim_space(tr0_nodes);
			td1 = claim_element(tr0_nodes, "TD", { class: true });
			var td1_nodes = children(td1);
			input0 = claim_element(td1_nodes, "INPUT", { type: true });
			td1_nodes.forEach(detach_dev);
			tr0_nodes.forEach(detach_dev);
			t4 = claim_space(tbody_nodes);
			if (if_block0) if_block0.l(tbody_nodes);
			t5 = claim_space(tbody_nodes);
			tr1 = claim_element(tbody_nodes, "TR", { class: true });
			var tr1_nodes = children(tr1);
			td2 = claim_element(tr1_nodes, "TD", { class: true });
			var td2_nodes = children(td2);
			t6 = claim_text(td2_nodes, "Login ID:");
			td2_nodes.forEach(detach_dev);
			t7 = claim_space(tr1_nodes);
			td3 = claim_element(tr1_nodes, "TD", { class: true });
			var td3_nodes = children(td3);
			input1 = claim_element(td3_nodes, "INPUT", {});
			td3_nodes.forEach(detach_dev);
			tr1_nodes.forEach(detach_dev);
			t8 = claim_space(tbody_nodes);
			tr2 = claim_element(tbody_nodes, "TR", { class: true });
			var tr2_nodes = children(tr2);
			td4 = claim_element(tr2_nodes, "TD", { class: true });
			var td4_nodes = children(td4);
			t9 = claim_text(td4_nodes, "Password:");
			td4_nodes.forEach(detach_dev);
			t10 = claim_space(tr2_nodes);
			td5 = claim_element(tr2_nodes, "TD", { class: true });
			var td5_nodes = children(td5);

			input2 = claim_element(td5_nodes, "INPUT", {
				type: true,
				autocomplete: true,
				readonly: true,
				onfocus: true,
				style: true
			});

			td5_nodes.forEach(detach_dev);
			tr2_nodes.forEach(detach_dev);
			t11 = claim_space(tbody_nodes);
			if (if_block1) if_block1.l(tbody_nodes);
			t12 = claim_space(tbody_nodes);
			if (if_block2) if_block2.l(tbody_nodes);
			t13 = claim_space(tbody_nodes);
			tr3 = claim_element(tbody_nodes, "TR", { class: true });
			var tr3_nodes = children(tr3);
			td6 = claim_element(tr3_nodes, "TD", { class: true });
			children(td6).forEach(detach_dev);
			t14 = claim_space(tr3_nodes);
			td7 = claim_element(tr3_nodes, "TD", { class: true });
			var td7_nodes = children(td7);
			button = claim_element(td7_nodes, "BUTTON", { type: true, disabled: true });
			var button_nodes = children(button);
			t15 = claim_text(button_nodes, t15_value);
			button_nodes.forEach(detach_dev);
			td7_nodes.forEach(detach_dev);
			tr3_nodes.forEach(detach_dev);
			tbody_nodes.forEach(detach_dev);
			table_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file, 97, 2, 2046);
			attr_dev(td0, "class", "svelte-lvl36j");
			add_location(td0, file, 101, 8, 2106);
			attr_dev(input0, "type", "checkbox");
			add_location(input0, file, 102, 12, 2147);
			attr_dev(td1, "class", "svelte-lvl36j");
			add_location(td1, file, 102, 8, 2143);
			attr_dev(tr0, "class", "svelte-lvl36j");
			add_location(tr0, file, 100, 6, 2093);
			attr_dev(td2, "class", "svelte-lvl36j");
			add_location(td2, file, 111, 8, 2357);
			add_location(input1, file, 112, 12, 2388);
			attr_dev(td3, "class", "svelte-lvl36j");
			add_location(td3, file, 112, 8, 2384);
			attr_dev(tr1, "class", "svelte-lvl36j");
			add_location(tr1, file, 110, 6, 2344);
			attr_dev(td4, "class", "svelte-lvl36j");
			add_location(td4, file, 115, 8, 2455);
			attr_dev(input2, "type", "password");
			attr_dev(input2, "autocomplete", "off");
			input2.readOnly = true;
			attr_dev(input2, "onfocus", "this.removeAttribute('readonly');");
			set_style(input2, "text-security", "disc");
			set_style(input2, "-webkit-text-security", "disc");
			add_location(input2, file, 116, 12, 2486);
			attr_dev(td5, "class", "svelte-lvl36j");
			add_location(td5, file, 116, 8, 2482);
			attr_dev(tr2, "class", "svelte-lvl36j");
			add_location(tr2, file, 114, 6, 2442);
			attr_dev(td6, "class", "svelte-lvl36j");
			add_location(td6, file, 131, 8, 3114);
			attr_dev(button, "type", "button");
			button.disabled = button_disabled_value = !/*username*/ ctx[1];
			add_location(button, file, 132, 12, 3136);
			attr_dev(td7, "class", "svelte-lvl36j");
			add_location(td7, file, 132, 8, 3132);
			attr_dev(tr3, "class", "svelte-lvl36j");
			add_location(tr3, file, 130, 6, 3101);
			add_location(tbody, file, 99, 4, 2079);
			add_location(table, file, 98, 2, 2067);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, table, anchor);
			append_dev(table, tbody);
			append_dev(tbody, tr0);
			append_dev(tr0, td0);
			append_dev(td0, t2);
			append_dev(tr0, t3);
			append_dev(tr0, td1);
			append_dev(td1, input0);
			input0.checked = /*register*/ ctx[4];
			append_dev(tbody, t4);
			if (if_block0) if_block0.m(tbody, null);
			append_dev(tbody, t5);
			append_dev(tbody, tr1);
			append_dev(tr1, td2);
			append_dev(td2, t6);
			append_dev(tr1, t7);
			append_dev(tr1, td3);
			append_dev(td3, input1);
			set_input_value(input1, /*username*/ ctx[1]);
			append_dev(tbody, t8);
			append_dev(tbody, tr2);
			append_dev(tr2, td4);
			append_dev(td4, t9);
			append_dev(tr2, t10);
			append_dev(tr2, td5);
			append_dev(td5, input2);
			set_input_value(input2, /*password*/ ctx[2]);
			append_dev(tbody, t11);
			if (if_block1) if_block1.m(tbody, null);
			append_dev(tbody, t12);
			if (if_block2) if_block2.m(tbody, null);
			append_dev(tbody, t13);
			append_dev(tbody, tr3);
			append_dev(tr3, td6);
			append_dev(tr3, t14);
			append_dev(tr3, td7);
			append_dev(td7, button);
			append_dev(button, t15);

			if (!mounted) {
				dispose = [
					listen_dev(input0, "change", /*input0_change_handler*/ ctx[10]),
					listen_dev(input1, "input", /*input1_input_handler*/ ctx[12]),
					listen_dev(input2, "input", /*input2_input_handler*/ ctx[13]),
					listen_dev(button, "click", /*onClick*/ ctx[8], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*register*/ 16) {
				input0.checked = /*register*/ ctx[4];
			}

			if (/*register*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					if_block0.m(tbody, t5);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*username*/ 2 && input1.value !== /*username*/ ctx[1]) {
				set_input_value(input1, /*username*/ ctx[1]);
			}

			if (dirty & /*password*/ 4 && input2.value !== /*password*/ ctx[2]) {
				set_input_value(input2, /*password*/ ctx[2]);
			}

			if (/*register*/ ctx[4]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					if_block1.m(tbody, t12);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*error*/ ctx[5]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_1(ctx);
					if_block2.c();
					if_block2.m(tbody, t13);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty & /*register*/ 16 && t15_value !== (t15_value = (/*register*/ ctx[4] ? "register" : "login") + "")) set_data_dev(t15, t15_value);

			if (dirty & /*username*/ 2 && button_disabled_value !== (button_disabled_value = !/*username*/ ctx[1])) {
				prop_dev(button, "disabled", button_disabled_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(table);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(97:0) {#if $session && !$session.loading}",
		ctx
	});

	return block;
}

// (105:6) {#if register}
function create_if_block_3(ctx) {
	let tr;
	let td0;
	let t0;
	let t1;
	let td1;
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			tr = element("tr");
			td0 = element("td");
			t0 = text("Full Name:");
			t1 = space();
			td1 = element("td");
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			tr = claim_element(nodes, "TR", { class: true });
			var tr_nodes = children(tr);
			td0 = claim_element(tr_nodes, "TD", { class: true });
			var td0_nodes = children(td0);
			t0 = claim_text(td0_nodes, "Full Name:");
			td0_nodes.forEach(detach_dev);
			t1 = claim_space(tr_nodes);
			td1 = claim_element(tr_nodes, "TD", { class: true });
			var td1_nodes = children(td1);
			input = claim_element(td1_nodes, "INPUT", {});
			td1_nodes.forEach(detach_dev);
			tr_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(td0, "class", "svelte-lvl36j");
			add_location(td0, file, 106, 8, 2250);
			add_location(input, file, 107, 12, 2282);
			attr_dev(td1, "class", "svelte-lvl36j");
			add_location(td1, file, 107, 8, 2278);
			attr_dev(tr, "class", "svelte-lvl36j");
			add_location(tr, file, 105, 6, 2237);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td0);
			append_dev(td0, t0);
			append_dev(tr, t1);
			append_dev(tr, td1);
			append_dev(td1, input);
			set_input_value(input, /*name*/ ctx[0]);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[11]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*name*/ 1 && input.value !== /*name*/ ctx[0]) {
				set_input_value(input, /*name*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(105:6) {#if register}",
		ctx
	});

	return block;
}

// (119:6) {#if register}
function create_if_block_2(ctx) {
	let tr;
	let td0;
	let t0;
	let t1;
	let td1;
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			tr = element("tr");
			td0 = element("td");
			t0 = text("Verify Password:");
			t1 = space();
			td1 = element("td");
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			tr = claim_element(nodes, "TR", { class: true });
			var tr_nodes = children(tr);
			td0 = claim_element(tr_nodes, "TD", { class: true });
			var td0_nodes = children(td0);
			t0 = claim_text(td0_nodes, "Verify Password:");
			td0_nodes.forEach(detach_dev);
			t1 = claim_space(tr_nodes);
			td1 = claim_element(tr_nodes, "TD", { class: true });
			var td1_nodes = children(td1);

			input = claim_element(td1_nodes, "INPUT", {
				type: true,
				autocomplete: true,
				readonly: true,
				onfocus: true,
				style: true
			});

			td1_nodes.forEach(detach_dev);
			tr_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(td0, "class", "svelte-lvl36j");
			add_location(td0, file, 120, 8, 2718);
			attr_dev(input, "type", "password");
			attr_dev(input, "autocomplete", "off");
			input.readOnly = true;
			attr_dev(input, "onfocus", "this.removeAttribute('readonly');");
			set_style(input, "text-security", "disc");
			set_style(input, "-webkit-text-security", "disc");
			add_location(input, file, 121, 12, 2756);
			attr_dev(td1, "class", "svelte-lvl36j");
			add_location(td1, file, 121, 8, 2752);
			attr_dev(tr, "class", "svelte-lvl36j");
			add_location(tr, file, 119, 6, 2705);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td0);
			append_dev(td0, t0);
			append_dev(tr, t1);
			append_dev(tr, td1);
			append_dev(td1, input);
			set_input_value(input, /*verify*/ ctx[3]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler_1*/ ctx[14]),
					listen_dev(input, "change", /*verifyPassword*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*verify*/ 8 && input.value !== /*verify*/ ctx[3]) {
				set_input_value(input, /*verify*/ ctx[3]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(119:6) {#if register}",
		ctx
	});

	return block;
}

// (125:6) {#if error}
function create_if_block_1(ctx) {
	let tr;
	let td0;
	let t0;
	let td1;
	let t1;

	const block = {
		c: function create() {
			tr = element("tr");
			td0 = element("td");
			t0 = space();
			td1 = element("td");
			t1 = text(/*error*/ ctx[5]);
			this.h();
		},
		l: function claim(nodes) {
			tr = claim_element(nodes, "TR", { class: true });
			var tr_nodes = children(tr);
			td0 = claim_element(tr_nodes, "TD", { class: true });
			children(td0).forEach(detach_dev);
			t0 = claim_space(tr_nodes);
			td1 = claim_element(tr_nodes, "TD", { class: true });
			var td1_nodes = children(td1);
			t1 = claim_text(td1_nodes, /*error*/ ctx[5]);
			td1_nodes.forEach(detach_dev);
			tr_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(td0, "class", "svelte-lvl36j");
			add_location(td0, file, 126, 8, 3022);
			attr_dev(td1, "class", "error svelte-lvl36j");
			add_location(td1, file, 127, 8, 3040);
			attr_dev(tr, "class", "svelte-lvl36j");
			add_location(tr, file, 125, 6, 3009);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td0);
			append_dev(tr, t0);
			append_dev(tr, td1);
			append_dev(td1, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*error*/ 32) set_data_dev(t1, /*error*/ ctx[5]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(125:6) {#if error}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div;
	let form;
	let if_block = /*$session*/ ctx[6] && !/*$session*/ ctx[6].loading && create_if_block(ctx);

	const block = {
		c: function create() {
			div = element("div");
			form = element("form");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			form = claim_element(div_nodes, "FORM", {});
			var form_nodes = children(form);
			if (if_block) if_block.l(form_nodes);
			form_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(form, file, 95, 0, 2001);
			attr_dev(div, "class", "center svelte-lvl36j");
			add_location(div, file, 94, 0, 1982);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, form);
			if (if_block) if_block.m(form, null);
		},
		p: function update(ctx, [dirty]) {
			if (/*$session*/ ctx[6] && !/*$session*/ ctx[6].loading) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(form, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $session;
	const { session } = stores$1();
	validate_store(session, "session");
	component_subscribe($$self, session, value => $$invalidate(6, $session = value));
	let name = "";
	let username = "nurse1";
	let password = "password";
	let verify = "";
	let register = false;
	let error;

	async function onClick() {
		if (register) {
			btnRegister();
		} else {
			btnLogin();
		}
	}

	async function btnLogin() {
		const response = await DoLogin(username, password);
		processResponse(response);
	}

	async function btnRegister() {
		if (!verifyPassword()) return;

		const response = await DoRegister({
			name,
			username,
			password,
			roles: ["nurse"]
		});

		processResponse(response);
	}

	async function processResponse(response) {
		if (response.ok) {
			const profile = await response.json();

			session.update(() => {
				return { authenticated: !!profile, profile };
			});

			if (!profile) $$invalidate(5, error = "login error");
			if (profile.roles.includes("nurse")) goto("patients");
		} else {
			session.update(() => {
				return { authenticated: false, profile: null };
			});

			if (response.text) $$invalidate(5, error = await response.text()); else $$invalidate(5, error = "server error");
		}
	}

	function verifyPassword() {
		if (name.length == 0) {
			$$invalidate(5, error = "name cannot be empty");
			return false;
		}

		if (password.length < 8) {
			$$invalidate(5, error = "password must be atleast 8 characters");
			return false;
		}

		if (verify != password) {
			$$invalidate(5, error = "passwords don't match");
			return false;
		}

		$$invalidate(5, error = null);
		return true;
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Login> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Login", $$slots, []);

	function input0_change_handler() {
		register = this.checked;
		$$invalidate(4, register);
	}

	function input_input_handler() {
		name = this.value;
		$$invalidate(0, name);
	}

	function input1_input_handler() {
		username = this.value;
		$$invalidate(1, username);
	}

	function input2_input_handler() {
		password = this.value;
		$$invalidate(2, password);
	}

	function input_input_handler_1() {
		verify = this.value;
		$$invalidate(3, verify);
	}

	$$self.$capture_state = () => ({
		goto,
		stores: stores$1,
		DoLogin,
		DoRegister,
		session,
		name,
		username,
		password,
		verify,
		register,
		error,
		onClick,
		btnLogin,
		btnRegister,
		processResponse,
		verifyPassword,
		$session
	});

	$$self.$inject_state = $$props => {
		if ("name" in $$props) $$invalidate(0, name = $$props.name);
		if ("username" in $$props) $$invalidate(1, username = $$props.username);
		if ("password" in $$props) $$invalidate(2, password = $$props.password);
		if ("verify" in $$props) $$invalidate(3, verify = $$props.verify);
		if ("register" in $$props) $$invalidate(4, register = $$props.register);
		if ("error" in $$props) $$invalidate(5, error = $$props.error);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		name,
		username,
		password,
		verify,
		register,
		error,
		$session,
		session,
		onClick,
		verifyPassword,
		input0_change_handler,
		input_input_handler,
		input1_input_handler,
		input2_input_handler,
		input_input_handler_1
	];
}

class Login extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Login",
			options,
			id: create_fragment.name
		});
	}
}

/* src\routes\index.svelte generated by Svelte v3.24.0 */
const file$1 = "src\\routes\\index.svelte";

// (24:0) {#if $session && !$session.loading}
function create_if_block_1$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_2$1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$session*/ ctx[0].authenticated) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(24:0) {#if $session && !$session.loading}",
		ctx
	});

	return block;
}

// (27:2) {:else}
function create_else_block(ctx) {
	let login;
	let current;
	login = new Login({ $$inline: true });

	const block = {
		c: function create() {
			create_component(login.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(login.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(login, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(login.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(login.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(login, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(27:2) {:else}",
		ctx
	});

	return block;
}

// (25:2) {#if $session.authenticated}
function create_if_block_2$1(ctx) {
	let p;
	let t0;
	let t1_value = /*$session*/ ctx[0].profile.name + "";
	let t1;

	const block = {
		c: function create() {
			p = element("p");
			t0 = text("Welcome, ");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "Welcome, ");
			t1 = claim_text(p_nodes, t1_value);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$1, 25, 4, 440);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t0);
			append_dev(p, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$session*/ 1 && t1_value !== (t1_value = /*$session*/ ctx[0].profile.name + "")) set_data_dev(t1, t1_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(25:2) {#if $session.authenticated}",
		ctx
	});

	return block;
}

// (31:0) {#if error}
function create_if_block$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*error*/ ctx[2]);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, /*error*/ ctx[2]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(31:0) {#if error}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let t0;
	let div;
	let t1;
	let current;
	let if_block0 = /*$session*/ ctx[0] && !/*$session*/ ctx[0].loading && create_if_block_1$1(ctx);
	let if_block1 = /*error*/ ctx[2] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			t0 = space();
			div = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-12q5rtj\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			document.title = "Patient Management System";
			attr_dev(div, "class", "center svelte-rzqpb7");
			add_location(div, file$1, 22, 0, 350);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*$session*/ ctx[0] && !/*$session*/ ctx[0].loading) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*$session*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*error*/ ctx[2]) if_block1.p(ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let $session;
	const { session } = stores$1();
	validate_store(session, "session");
	component_subscribe($$self, session, value => $$invalidate(0, $session = value));
	let error;
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Routes> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Routes", $$slots, []);

	$$self.$capture_state = () => ({
		goto,
		stores: stores$1,
		Login,
		session,
		error,
		$session
	});

	$$self.$inject_state = $$props => {
		if ("error" in $$props) $$invalidate(2, error = $$props.error);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [$session, session, error];
}

class Routes extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Routes",
			options,
			id: create_fragment$1.name
		});
	}
}

export default Routes;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguNDRlODM0NzMuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zZXNzaW9uLmpzIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvTG9naW4uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9pbmRleC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIERvTG9naW4odXNlcm5hbWUsIHBhc3N3b3JkKSB7XG4gIHJldHVybiBmZXRjaCgnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaS92MS9zZXNzaW9uJywge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIG1vZGU6ICdjb3JzJyxcbiAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICB9LFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmRcbiAgICB9KVxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRG9SZWdpc3Rlcih1c2VyKSB7XG4gIHJldHVybiBmZXRjaCgnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaS92MS9yZWdpc3RlcicsIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBtb2RlOiAnY29ycycsXG4gICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgfSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1c2VyKVxuICB9KVxufVxuXG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBnb3RvLCBzdG9yZXMgfSBmcm9tICdAc2FwcGVyL2FwcCdcbiAgaW1wb3J0IHsgRG9Mb2dpbiwgRG9SZWdpc3RlciB9IGZyb20gJy4uL3Nlc3Npb24uanMnXG4gIFxuICBjb25zdCB7IHNlc3Npb24gfSA9IHN0b3JlcygpXG4gIGxldCBuYW1lID0gJydcbiAgbGV0IHVzZXJuYW1lID0gJ251cnNlMSdcbiAgbGV0IHBhc3N3b3JkID0gJ3Bhc3N3b3JkJ1xuICBsZXQgdmVyaWZ5ID0gJydcbiAgbGV0IHJlZ2lzdGVyID0gZmFsc2VcbiAgbGV0IGVycm9yXG5cbiAgYXN5bmMgZnVuY3Rpb24gb25DbGljayAoKSB7XG4gICAgaWYgKHJlZ2lzdGVyKSB7XG4gICAgICBidG5SZWdpc3RlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidG5Mb2dpbigpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGJ0bkxvZ2luKCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgRG9Mb2dpbih1c2VybmFtZSwgcGFzc3dvcmQpO1xuICAgIHByb2Nlc3NSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBidG5SZWdpc3RlcigpIHtcbiAgICBpZiAoIXZlcmlmeVBhc3N3b3JkKCkpIHJldHVybjtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IERvUmVnaXN0ZXIoe1xuICAgICAgbmFtZSxcbiAgICAgIHVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQsXG4gICAgICByb2xlczogW1wibnVyc2VcIl1cbiAgICB9KTtcbiAgICBwcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgc2Vzc2lvbi51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aGVudGljYXRlZDogISFwcm9maWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICBpZiAoIXByb2ZpbGUpXG4gICAgICAgIGVycm9yID0gJ2xvZ2luIGVycm9yJ1xuICAgICAgaWYgKHByb2ZpbGUucm9sZXMuaW5jbHVkZXMoJ251cnNlJykpXG4gICAgICAgIGdvdG8oJ3BhdGllbnRzJylcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vzc2lvbi51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aGVudGljYXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9maWxlIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICBpZiAocmVzcG9uc2UudGV4dClcbiAgICAgICAgZXJyb3IgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICAgIGVsc2VcbiAgICAgICAgZXJyb3IgPSBcInNlcnZlciBlcnJvclwiXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdmVyaWZ5UGFzc3dvcmQoKSB7XG4gICAgaWYgKG5hbWUubGVuZ3RoID09IDApIHtcbiAgICAgIGVycm9yID0gXCJuYW1lIGNhbm5vdCBiZSBlbXB0eVwiXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKHBhc3N3b3JkLmxlbmd0aCA8IDgpIHtcbiAgICAgIGVycm9yID0gXCJwYXNzd29yZCBtdXN0IGJlIGF0bGVhc3QgOCBjaGFyYWN0ZXJzXCJcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAodmVyaWZ5ICE9IHBhc3N3b3JkKSB7XG4gICAgICBlcnJvciA9IFwicGFzc3dvcmRzIGRvbid0IG1hdGNoXCJcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBlcnJvciA9IG51bGxcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICAuY2VudGVyIHtcbiAgICBtYXJnaW46IGF1dG87XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgfVxuXG4gIC50YWJsZSB0ciB0ZCB7XG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gIH0gIFxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1jZW50ZXI+XG48Zm9ybT5cbnsjaWYgJHNlc3Npb24gJiYgISRzZXNzaW9uLmxvYWRpbmd9XG4gIDxwPk51cnNlIExvZ2luPC9wPlxuICA8dGFibGU+XG4gICAgPHRib2R5PlxuICAgICAgPHRyPlxuICAgICAgICA8dGQ+UmVnaXN0ZXIgbmV3IHVzZXIgPzwvdGQ+XG4gICAgICAgIDx0ZD48aW5wdXQgdHlwZT1jaGVja2JveCBiaW5kOmNoZWNrZWQ9e3JlZ2lzdGVyfT48L3RkPlxuICAgICAgPC90cj5cbiAgICAgIHsjaWYgcmVnaXN0ZXJ9XG4gICAgICA8dHI+XG4gICAgICAgIDx0ZD5GdWxsIE5hbWU6PC90ZD5cbiAgICAgICAgPHRkPjxpbnB1dCBiaW5kOnZhbHVlPXtuYW1lfS8+PC90ZD5cbiAgICAgIDwvdHI+XG4gICAgICB7L2lmfVxuICAgICAgPHRyPlxuICAgICAgICA8dGQ+TG9naW4gSUQ6PC90ZD5cbiAgICAgICAgPHRkPjxpbnB1dCBiaW5kOnZhbHVlPXt1c2VybmFtZX0vPjwvdGQ+XG4gICAgICA8L3RyPlxuICAgICAgPHRyPlxuICAgICAgICA8dGQ+UGFzc3dvcmQ6PC90ZD5cbiAgICAgICAgPHRkPjxpbnB1dCB0eXBlPVwicGFzc3dvcmRcIiBiaW5kOnZhbHVlPXtwYXNzd29yZH0gYXV0b2NvbXBsZXRlPVwib2ZmXCIgcmVhZG9ubHkgb25mb2N1cz1cInRoaXMucmVtb3ZlQXR0cmlidXRlKCdyZWFkb25seScpO1wiIHN0eWxlPVwidGV4dC1zZWN1cml0eTpkaXNjOyAtd2Via2l0LXRleHQtc2VjdXJpdHk6ZGlzYztcIi8+PC90ZD5cbiAgICAgIDwvdHI+XG4gICAgICB7I2lmIHJlZ2lzdGVyfVxuICAgICAgPHRyPlxuICAgICAgICA8dGQ+VmVyaWZ5IFBhc3N3b3JkOjwvdGQ+XG4gICAgICAgIDx0ZD48aW5wdXQgdHlwZT1cInBhc3N3b3JkXCIgYmluZDp2YWx1ZT17dmVyaWZ5fSBvbjpjaGFuZ2U9e3ZlcmlmeVBhc3N3b3JkfSBhdXRvY29tcGxldGU9XCJvZmZcIiByZWFkb25seSBvbmZvY3VzPVwidGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3JlYWRvbmx5Jyk7XCIgc3R5bGU9XCJ0ZXh0LXNlY3VyaXR5OmRpc2M7IC13ZWJraXQtdGV4dC1zZWN1cml0eTpkaXNjO1wiLz48L3RkPlxuICAgICAgPC90cj5cbiAgICAgIHsvaWZ9XG4gICAgICB7I2lmIGVycm9yfVxuICAgICAgPHRyPlxuICAgICAgICA8dGQ+PC90ZD5cbiAgICAgICAgPHRkIGNsYXNzPVwiZXJyb3JcIj57ZXJyb3J9PC90ZD5cbiAgICAgIDwvdHI+XG4gICAgICB7L2lmfVxuICAgICAgPHRyPlxuICAgICAgICA8dGQ+PC90ZD5cbiAgICAgICAgPHRkPjxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRpc2FibGVkPXshdXNlcm5hbWV9IG9uOmNsaWNrPXtvbkNsaWNrfT57cmVnaXN0ZXI/IFwicmVnaXN0ZXJcIiA6IFwibG9naW5cIn0gPC9idXR0b24+PC90ZD5cbiAgICAgIDwvdHI+XG4gICAgPC90Ym9keT5cbiAgPC90YWJsZT4gIFxuey9pZn1cbjwvZm9ybT5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgZ290bywgc3RvcmVzIH0gZnJvbSAnQHNhcHBlci9hcHAnXG4gIGltcG9ydCBMb2dpbiBmcm9tICcuLi9jb21wb25lbnRzL0xvZ2luLnN2ZWx0ZSdcbiAgXG4gIGNvbnN0IHsgc2Vzc2lvbiB9ID0gc3RvcmVzKClcbiAgbGV0IGVycm9yXG5cbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIC5jZW50ZXIge1xuICAgIG1hcmdpbjogYXV0bztcbiAgICB3aWR0aDogMTAwJTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICB9XG48L3N0eWxlPlxuXG48c3ZlbHRlOmhlYWQ+XG5cdDx0aXRsZT5QYXRpZW50IE1hbmFnZW1lbnQgU3lzdGVtPC90aXRsZT5cbjwvc3ZlbHRlOmhlYWQ+XG5cbjxkaXYgY2xhc3M9Y2VudGVyPlxueyNpZiAkc2Vzc2lvbiAmJiAhJHNlc3Npb24ubG9hZGluZ31cbiAgeyNpZiAkc2Vzc2lvbi5hdXRoZW50aWNhdGVkfVxuICAgIDxwPldlbGNvbWUsIHskc2Vzc2lvbi5wcm9maWxlLm5hbWV9PC9wPlxuICB7OmVsc2V9XG4gICAgPExvZ2luLz5cbiAgey9pZn1cbnsvaWZ9XG57I2lmIGVycm9yfVxuICB7ZXJyb3J9XG57L2lmfVxuPC9kaXY+XG4iXSwibmFtZXMiOlsic3RvcmVzIl0sIm1hcHBpbmdzIjoiOztBQUFPLFNBQVMsT0FBTyxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUU7QUFDNUMsRUFBRSxPQUFPLEtBQUssQ0FBQyxzQ0FBc0MsRUFBRTtBQUN2RCxJQUFJLE1BQU0sRUFBRSxNQUFNO0FBQ2xCLElBQUksSUFBSSxFQUFFLE1BQU07QUFDaEIsSUFBSSxXQUFXLEVBQUUsU0FBUztBQUMxQixJQUFJLE9BQU8sRUFBRTtBQUNiLE1BQU0sY0FBYyxFQUFFLGtCQUFrQjtBQUN4QyxLQUFLO0FBQ0wsSUFBSSxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQztBQUN6QixNQUFNLFFBQVE7QUFDZCxNQUFNLFFBQVE7QUFDZCxLQUFLLENBQUM7QUFDTixHQUFHLENBQUM7QUFDSixDQUFDO0FBQ0Q7QUFDTyxTQUFTLFVBQVUsQ0FBQyxJQUFJLEVBQUU7QUFDakMsRUFBRSxPQUFPLEtBQUssQ0FBQyx1Q0FBdUMsRUFBRTtBQUN4RCxJQUFJLE1BQU0sRUFBRSxNQUFNO0FBQ2xCLElBQUksSUFBSSxFQUFFLE1BQU07QUFDaEIsSUFBSSxXQUFXLEVBQUUsU0FBUztBQUMxQixJQUFJLE9BQU8sRUFBRTtBQUNiLE1BQU0sY0FBYyxFQUFFLGtCQUFrQjtBQUN4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
